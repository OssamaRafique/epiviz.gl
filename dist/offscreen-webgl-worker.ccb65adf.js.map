{"mappings":"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","sources":["src/epiviz.gl/offscreen-webgl-worker.js","src/epiviz.gl/webgl-drawer.js","src/epiviz.gl/drawer.js","src/epiviz.gl/semantic-zoomer.js","src/epiviz.gl/webgl.js"],"sourcesContent":["/**\n * The offscreen webgl worker is meant to communicate from the {@link WebGLVis}\n * by sending a specification data to the drawer for management of shader program and\n * eventually drawing. Most messages passed are containing the new viewport\n * information for the drawer to process.\n */\nimport WebGLDrawer from \"./webgl-drawer\";\n\nclass OffscreenWebGLDrawer extends WebGLDrawer {\n  tick() {\n    postMessage({ type: \"tick\" });\n  }\n}\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.drawer = message.data.displayFPSMeter\n        ? new OffscreenWebGLDrawer(message.data)\n        : new WebGLDrawer(message.data);\n      break;\n    case \"viewport\":\n      self.drawer.receiveViewport(message.data);\n      break;\n    case \"render\":\n      self.drawer.receiveViewport(message.data);\n      self.drawer.render();\n      break;\n    case \"specification\":\n      self.drawer.setSpecification(message.data.specification);\n      break;\n    case \"clearBuffers\":\n      self.drawer.clearBuffers();\n      break;\n    case \"resize\":\n      self.drawer.canvas.width = message.data.width;\n      self.drawer.canvas.height = message.data.height;\n      self.drawer.gl.viewport(0, 0, message.data.width, message.data.height);\n      break;\n    default:\n      console.error(`Received unknown message type: ${message.type}`);\n  }\n};\n","import Drawer from \"./drawer\";\nimport SpecificationProcessor from \"./specification-processor\";\nimport { scale } from \"./utilities\";\nimport VertexCalculator from \"./vertex-calculator\";\nimport SemanticZoomer from \"./semantic-zoomer\";\nimport { VertexShader, varyingColorsFragmentShader } from \"./webgl.js\";\n\nimport * as twgl from \"twgl.js\";\n\nconst ALL_POTENTIAL_ATTRIBUTES = VertexShader.SUPPORTED_CHANNEL_ATTRIBUTES.map(\n  (attr) => `a_${attr}`\n).concat(\"a_VertexPosition\");\n\nclass WebGLCanvasDrawer extends Drawer {\n  constructor(viewportData) {\n    super(viewportData);\n\n    this.gl = this.canvas.getContext(\"webgl2\", {\n      // Setting these to false makes webgl handle more like opengl\n      // Source: https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html\n      alpha: false,\n      premultipliedAlpha: false,\n    });\n\n    if (!this.gl) {\n      console.error(\"Unable to initialize WebGL!\");\n      return;\n    }\n  }\n\n  /**\n   * Called whenever a frame has been successfully animated.\n   */\n  tick() {}\n\n  /**\n   * Calculates the viewport for this.gl.viewport to control zooming. Also calculates point size.\n   * @returns Array of 5 elements, first 4 are viewport parameters, last is pointSizeMultiplier:\n   *   [xOffset, yOffset, displayAsIfThisWide, displayAsIfThisHigh, pointSizeMultiplier]\n   */\n  getWebGLViewport() {\n    // Calculate appropriate webgl viewport given current selection window\n\n    // Transform current data coordinates to GPU cordinates\n    const scaleXWindowSpace = scale([this.minX, this.maxX], [-1, 1]);\n    const scaleYWindowSpace = scale([this.minY, this.maxY], [-1, 1]);\n\n    // Multiply point size by the ratio of max dimension and current width\n    const pointSize = Math.max(\n      1,\n      Math.min(\n        1 /\n          (scaleXWindowSpace(this.currentXRange[1]) -\n            scaleXWindowSpace(this.currentXRange[0])),\n        1 /\n          (scaleYWindowSpace(this.currentYRange[1]) -\n            scaleYWindowSpace(this.currentYRange[0]))\n      )\n    );\n    // Return [x1, y1, x2, y2] and pointsize, camera corners coordinates in GPU space\n    // Which becomes uniform in vertex shader\n    return [\n      scaleXWindowSpace(this.currentXRange[0]),\n      scaleYWindowSpace(this.currentYRange[0]),\n      scaleXWindowSpace(this.currentXRange[1]),\n      scaleYWindowSpace(this.currentYRange[1]),\n      pointSize,\n    ];\n  }\n\n  /**\n   * Sets the specification and begins the process of drawing it.\n   *  1. Cancels any current animation\n   *  2. Builds shaders for the tracks\n   *  3. After data is loaded, calls populateBuffers.\n   *\n   * @param {Object} specification of visualization\n   */\n  setSpecification(specification) {\n    super.render(); // Cancels current animation frame\n\n    // Populate buffers needs a trackShader built to know what buffers to fill\n    this.trackShaders = VertexShader.fromSpecification(specification);\n\n    new SpecificationProcessor(specification, this.populateBuffers.bind(this));\n  }\n\n  /**\n   * Populate the buffers that are fed to webgl for drawing.\n   *\n   * @param {SpecificationProcessor} specificationHelper created in the setSpecification method\n   */\n  populateBuffers(specificationHelper) {\n    let currentTrack = specificationHelper.getNextTrack();\n    let currentTrackShaderIndex = 0;\n\n    this.semanticZoomer = new SemanticZoomer(specificationHelper);\n\n    while (currentTrack) {\n      // Construct calculator in track loop as calculator keeps internal state for each track\n      let vertexCalculator = new VertexCalculator(\n        specificationHelper.xScale,\n        specificationHelper.yScale,\n        currentTrack.track // Access actual track specification\n      );\n\n      let currentMark = currentTrack.getNextMark();\n\n      while (currentMark) {\n        // A lot of the heavy lifting occurs in the track shaders, this class is mostly boilerplate for webgl\n        this.trackShaders[currentTrackShaderIndex].addMarkToBuffers(\n          currentMark,\n          vertexCalculator\n        );\n\n        currentMark = currentTrack.getNextMark();\n      }\n\n      currentTrack = specificationHelper.getNextTrack();\n      currentTrackShaderIndex++;\n    }\n\n    this.render();\n  }\n\n  /**\n   * Animates the frames by setting viewport, uniforms, blending, clearing, and calling webgl draw.\n   */\n  animate() {\n    if (!this.needsAnimation) {\n      // Prevent pointless animation if canvas does not change\n      this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n      this.tick();\n      return;\n    }\n\n    const viewport = this.getWebGLViewport();\n    this.globalUniforms.viewport = new Float32Array(viewport.slice(0, 4));\n    this.globalUniforms.pointSizeModifier = viewport[4];\n\n    // Clear the canvas before we start drawing on it.\n    this.gl.clearColor(1, 1, 1, 1);\n\n    // Set the blending function\n    // Blend functions are weird, play with them:\n    // https://mrdoob.github.io/webgl-blendfunctions/blendfunc.html\n    // http://www.andersriggelsen.dk/glblendfunc.php\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // For each track shader, use their shader program then draw it\n    this.trackShaders.forEach((trackShader, index) => {\n      this.gl.useProgram(this.programInfos[index].program);\n\n      twgl.setUniforms(this.programInfos[index], {\n        ...this.globalUniforms,\n        ...trackShader.uniforms,\n      });\n\n      twgl.setBuffersAndAttributes(\n        this.gl,\n        this.programInfos[index],\n        this.vertexArrayInfos[index]\n      );\n\n      twgl.drawBufferInfo(\n        this.gl,\n        this.vertexArrayInfos[index],\n        this.gl[\n          this.semanticZoomer.getRecommendedDrawingMode(\n            trackShader,\n            this.currentXRange,\n            this.currentYRange\n          )\n        ],\n        trackShader.attributes.a_VertexPosition.data.length / 2\n      );\n    });\n\n    this.needsAnimation = false;\n    this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n    this.tick();\n  }\n\n  /**\n   * Prepares animation by compiling shaders, setting uniforms, constructing buffers,\n   * and handling additional boilerplate.\n   */\n  render() {\n    super.render();\n\n    this.programInfos = this.trackShaders.map((trackShader) =>\n      twgl.createProgramInfo(\n        this.gl,\n        [trackShader.buildShader(), varyingColorsFragmentShader],\n        ALL_POTENTIAL_ATTRIBUTES\n      )\n    );\n\n    this.globalUniforms = {\n      viewport: new Float32Array([-1, -1, 1, 1]),\n      pointSizeModifier: 1,\n    };\n\n    this.vertexArrayInfos = this.trackShaders.map((trackShader) =>\n      twgl.createVertexArrayInfo(\n        this.gl,\n        this.programInfos,\n        twgl.createBufferInfoFromArrays(this.gl, trackShader.attributes)\n      )\n    );\n\n    this.needsAnimation = true;\n    this.animate();\n  }\n}\n\nexport default WebGLCanvasDrawer;\n","class Drawer {\n  /**\n   * An interface for drawing on a canvas.\n   *\n   * @param {Object} drawingData object containing keys for {@link Drawer#receiveViewport}\n   *  and canvas key used for drawing.\n   */\n  constructor(drawingData) {\n    this.canvas = drawingData.canvas;\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.receiveViewport(drawingData);\n  }\n\n  /**\n   * Method to set the viewport for the drawer.\n   *\n   * @param {Object} viewportData object containing minX,maxX,minY,maxY,xRange,yRange viewport data for drawer\n   */\n  receiveViewport(viewportData) {\n    this.minX = viewportData.minX;\n    this.maxX = viewportData.maxX;\n    this.minY = viewportData.minY;\n    this.maxY = viewportData.maxY;\n    this.currentXRange = viewportData.xRange;\n    this.currentYRange = viewportData.yRange;\n\n    this.needsAnimation = true;\n  }\n\n  /**\n   * Method to implement which signifies a frame has been processed. Used to\n   * display FPS meter.\n   */\n  tick() {}\n\n  /**\n   * Method to implement animating a frame.\n   */\n  animate() {}\n\n  /**\n   * Method to implement preprocessing for rendering frames.\n   */\n  render() {\n    if (this.lastFrame) {\n      // Avoid overlapping animation requests\n      cancelAnimationFrame(this.lastFrame);\n    }\n  }\n}\n\nexport default Drawer;\n","const sizeOfGeneRangeForTriangles = 1000000;\n\nclass SemanticZoomer {\n  /**\n   * Gives guidance or takes control over canvas when semantic zooming\n   * is necessary. Developers should extend this class to create semantic zooming\n   * behavior.\n   * @param {SpecificationProcessor} specificationHelper\n   */\n  constructor(specificationHelper) {\n    this.specificationHelper = specificationHelper;\n  }\n\n  getRecommendedDrawingMode(trackShader, currentXRange, currentYRange) {\n    if (trackShader.drawMode !== \"TRIANGLES\") {\n      return trackShader.drawMode;\n    }\n\n    if (\n      !this.specificationHelper.xScale.isGenomeScale &&\n      !this.specificationHelper.yScale.isGenomeScale\n    ) {\n      // Currently only used for genome tracks\n      return \"TRIANGLES\";\n    }\n    if (this.specificationHelper.xScale.isGenomeScale) {\n      const numberOfGenes =\n        this.specificationHelper.xScale.mapGenomeIndexToClipSpaceInverse(\n          currentXRange[1]\n        ) -\n        this.specificationHelper.xScale.mapGenomeIndexToClipSpaceInverse(\n          currentXRange[0]\n        );\n      if (numberOfGenes < sizeOfGeneRangeForTriangles) {\n        return \"TRIANGLES\";\n      }\n    }\n    if (this.specificationHelper.yScale.isGenomeScale) {\n      const numberOfGenes =\n        this.specificationHelper.yScale.mapGenomeIndexToClipSpaceInverse(\n          currentYRange[1]\n        ) -\n        this.specificationHelper.yScale.mapGenomeIndexToClipSpaceInverse(\n          currentYRange[0]\n        );\n      if (numberOfGenes < sizeOfGeneRangeForTriangles) {\n        return \"TRIANGLES\";\n      }\n    }\n\n    return \"LINES\";\n  }\n}\n\nexport default SemanticZoomer;\n","import {\n  DEFAULT_CHANNELS,\n  getDrawModeForTrack,\n} from \"./specification-processor\";\nimport { colorSpecifierToHex } from \"./utilities\";\n\n/**\n * A vertex shader meant to take in positions, colors, and contain uniforms for zooming and panning.\n */\nconst baseVertexShader = `#version 300 es\n  precision highp float;\n\n  in vec2 a_VertexPosition;\n\n  uniform float pointSizeModifier;\n  // [x1, y1,x2, y2] of viewing window\n  uniform vec4 viewport;\n\n  out vec4 vColor;\n`;\n\n/**\n * Appended to end of vertex shader. Includes math for zooming and panning,\n * ability to unpack colors and send to fragment shader.\n */\nconst vertexShaderSuffix = (opacityName, colorName, sizeName) => `\n  vec3 unpackColor(float f) {\n    vec3 colorVec;\n    colorVec.r = floor(f / 65536.0);\n    colorVec.g = floor((f - colorVec.r * 65536.0) / 256.0);\n    colorVec.b = floor(f - colorVec.r * 65536.0 - colorVec.g * 256.0);\n    return colorVec / 256.0;\n  }\n\n  void main(void) {\n    // Subtract each vertex by midpoint of the viewport \n    // window to center points. Then scale by ratio of max window size to window size\n    gl_Position = vec4(\n       (a_VertexPosition.x - (viewport.z + viewport.x)/2.0) * 2.0/(viewport.z - viewport.x),\n       (a_VertexPosition.y - (viewport.w + viewport.y)/2.0) * 2.0/(viewport.w - viewport.y),\n        0,\n        1\n    );\n    vec3 unpackedValues = unpackColor(${colorName});\n\n    vColor = vec4(\n      unpackedValues.rgb,\n      ${opacityName}\n    );\n    gl_PointSize = ${sizeName} * pointSizeModifier;\n  }\n`;\n\n/**\n * A fragment shader which chooses color simply passed to by vertex shader.\n */\nconst varyingColorsFragmentShader = `#version 300 es\n  precision highp float;\n\n  in vec4 vColor;\n\n  out vec4 outColor;\n  void main(void) {\n    outColor = vColor;\n  }\n`;\n\nclass VertexShader {\n  static SUPPORTED_CHANNEL_ATTRIBUTES = Object.freeze([\n    \"color\",\n    \"size\",\n    \"opacity\",\n  ]);\n\n  /**\n   * A class meant to contain all the relevant information for a shader program, such as uniforms\n   * attributes, and ultimately the vertices. Do not use the constructor. Use VertexShader.fromSpecification\n   * or fromTrack instead.\n   */\n  constructor() {\n    this.shader = baseVertexShader;\n    this.uniforms = {};\n\n    // Add position buffers here since x and y channels don't map nicely to shader code\n    this.attributes = {\n      a_VertexPosition: {\n        numComponents: 2,\n        data: [],\n      },\n    };\n  }\n\n  /**\n   * Add a mark to the buffers by calculating its vertices, then adding its\n   * attributes such as size, color, or opacity to the buffers.\n   *\n   * @param {Object} mark passed in from SpecificationHelper in webgl-drawer.js\n   * @param {VertexCalculator} vertexCalculator used to calculate vertices for a track\n   */\n  addMarkToBuffers(mark, vertexCalculator) {\n    const vertices = vertexCalculator.calculateForMark(mark);\n    this.attributes.a_VertexPosition.data.push(...vertices);\n\n    for (const channel of Object.keys(this.attributes)) {\n      if (channel === \"a_VertexPosition\") {\n        // handled above\n        continue;\n      }\n\n      for (let i = 0; i < vertices.length / 2; i++) {\n        this.attributes[channel].data.push(mark[channel.substring(2)]); // Remove \"a_\" prefix\n      }\n    }\n\n    this.lastMark = mark;\n  }\n\n  /**\n   * Set the webgl draw mode to use\n   * @param {String} drawMode\n   */\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n  }\n\n  /**\n   * Signify this channel varies from mark to mark, so build buffers to carry this info\n   * for the program. Also add desclaration to shader code.\n   *\n   * @param {String} channel such as opacity, color, size\n   * @param {Number} numComponents number of components of this attribute to pull in, usually 1\n   * @returns this\n   */\n  addChannelBuffer(channel, numComponents = 1) {\n    this.attributes[`a_${channel}`] = { numComponents, data: [] };\n    this.shader += `in float a_${channel};\\n`;\n    return this;\n  }\n\n  /**\n   * Signify this channel is the same for every mark, so set a uniform to refer to.\n   *\n   * @param {String} channel such as opacity, color, size\n   * @param {Number} uniform value to set uniform to, must be a float\n   * @returns this\n   */\n  setChannelUniform(channel, uniform) {\n    this.uniforms[`u_${channel}`] = uniform;\n    this.shader += `uniform float u_${channel};\\n`;\n    return this;\n  }\n\n  /**\n   * Build the shader code after uniforms and attributes have been finalized.\n   *\n   * @returns shader code to compile\n   */\n  buildShader() {\n    // Assumes color, opacity, size channels have been used in\n    // addChannelBuffer or addChannelUniform\n    if (this.built) {\n      return this.shader;\n    }\n\n    const colorName = \"a_color\" in this.attributes ? \"a_color\" : \"u_color\";\n    const opacityName =\n      \"a_opacity\" in this.attributes ? \"a_opacity\" : \"u_opacity\";\n    const sizeName = \"a_size\" in this.attributes ? \"a_size\" : \"u_size\";\n\n    this.shader += vertexShaderSuffix(opacityName, colorName, sizeName);\n    this.built = true;\n    return this.shader;\n  }\n\n  /**\n   * Construct the vertex shaders for each track in the specification.\n   *\n   * @param {Object} specification of visualization\n   * @returns an array of {@link VertexShaders}s\n   */\n  static fromSpecification(specification) {\n    // Returns one per track\n    return specification.tracks.map(VertexShader.fromTrack);\n  }\n\n  /**\n   * Construct the vertex shader a track including setting attributes, uniforms, drawMode.\n   *\n   * @param {Object} track from specification\n   * @returns a {@link VertexShaders}\n   */\n  static fromTrack(track) {\n    // Given a track produce attributes and uniforms that describe a webgl drawing\n\n    const vsBuilder = new VertexShader();\n    vsBuilder.setDrawMode(getDrawModeForTrack(track));\n\n    for (let channel of Object.keys(DEFAULT_CHANNELS)) {\n      if (channel === \"shape\") {\n        // Changes vertex positions and draw mode, does not change shader code\n        continue;\n      }\n      if (channel in track) {\n        // Specification specifies channel\n        if (track[channel].value) {\n          // Channel has default value\n          if (channel === \"color\") {\n            track[channel].value = colorSpecifierToHex(track[channel].value);\n          }\n          vsBuilder.setChannelUniform(channel, track[channel].value);\n        } else {\n          // Set Channel as attribute, x and y will always reach here\n          if (channel === \"y\" || channel === \"x\") {\n            // Skip for x and y as handled in constructor\n            continue;\n          }\n\n          // These are currently the only supported channels for shader usage\n          if (VertexShader.SUPPORTED_CHANNEL_ATTRIBUTES.includes(channel)) {\n            vsBuilder.addChannelBuffer(\n              channel,\n              DEFAULT_CHANNELS[channel].numComponents\n            );\n          }\n        }\n      } else {\n        // Channel not listed, set default\n        if (VertexShader.SUPPORTED_CHANNEL_ATTRIBUTES.includes(channel)) {\n          vsBuilder.setChannelUniform(channel, DEFAULT_CHANNELS[channel].value);\n        }\n      }\n    }\n\n    return vsBuilder;\n  }\n}\n\nexport { varyingColorsFragmentShader, VertexShader };\n"],"names":[],"version":3,"file":"offscreen-webgl-worker.ccb65adf.js.map"}